# フロントエンド開発ディレクトリ構造ガイド

## 全体像のメンタルモデル

- **src** はアプリ本体。ここだけ触っていけば機能が増やせる。
- **features** は機能の島。API/UI/ロジックが1機能ごとに完結する。
- **components** は汎用部品置き場。どの機能にも染まらない再利用パーツ。
- **pages** は画面（ルート）。島々（features）や部品を組み合わせてページを組む。
- **services** は外との窓口。APIクライアントや外部ライブラリの初期化。
- **styles・assets** は見た目、**utils・types** は共通知恵、**store** は全体状態。

この“島モデル”を守ると、迷子になりません。

---

## 日常で触る場所（優先度順）

### `src/pages/`
- **役割:** ルーティング単位のページ。URLに対応する“画面の骨組み”。
- **日常の作業:** 新しい画面を作る時にファイルを追加（例: `ShiftList.tsx`）。
- **ポイント:** ページは「組み立て役」。ロジックやAPI直叩きは最小限に。

### `src/features/＜機能名＞/`
- **役割:** 機能ごとの完結した領域（例: `hello`, `shift`, `auth`）。
- **下層構造:**
  - `api/` … 機能専用のAPI関数（例: `getShifts.ts`）
  - `components/` … 機能内だけで使うUI（例: `ShiftTable.tsx`）
  - `hooks/` … 機能内の取得・状態・副作用（例: `useShifts.ts`）
  - `types.ts` … その機能の型（例: `Shift`, `ShiftFilter`）
- **ポイント:** “この機能のことは、この島で完結する”が正解。外に漏らさない。

### `src/components/`
- **役割:** 完全に汎用なUI（ボタン、モーダル、フォーム、表など）。
- **判断基準:** 他機能でもそのまま使い回せるか。依存が薄いか。

### `src/services/`
- **役割:** 共通APIクライアントや設定（例: `apiClient.ts` で fetch/axios をラップ）。
- **ポイント:** ベースURL、共通ヘッダ、エラーハンドリングをここに集約。

### `src/styles/` と `src/assets/`
- **役割:** スタイルと静的資産（画像、フォント）。
- **ポイント:** コンポーネント固有のスタイルは同居でもOK。グローバルは styles へ。

### `src/utils/` と `src/types/`
- **役割:** 日付フォーマット、バリデーション、共通型など“どの島でも使う知恵”。
- **ポイント:** 機能固有は features 側へ、横断的なものはここへ。

### `src/hooks/`
- **役割:** アプリ横断で使えるカスタムフック（例: `useToggle`, `useDebounce`）。
- **ポイント:** 逆に機能に強く依存するなら `features/＜機能名＞/hooks` へ。

---

## 補助的に理解しておく場所

### `index.html`
- **役割:** 1枚の HTML の“入れ物”。`<div id="root" />` に React を描画。
- **触る頻度:** 低（メタタグやフォントの追加時に編集）。

### `src/main.tsx`
- **役割:** React アプリのエントリーポイント（ルーター/状態管理の初期化）。
- **よくやること:** Router/Provider の設定、グローバルCSSの読み込み。

### `.env` / `.env.example`
- **役割:** 環境変数（例: `VITE_API_BASE_URL`）。`.env.example` は共有用の雛形。
- **ポイント:** 秘匿値は入れない。URLやフラグなどのみ。

### `vite.config.ts`
- **役割:** 開発サーバー、パスエイリアス、プラグイン設定。
- **おすすめ:** `@` を `src` に向けると import が短くなる。
  - 例: `import Hello from '@/features/hello/components/HelloMessage'`

### `tsconfig.json`
- **役割:** TypeScript の設定。パスエイリアスや strict オプションの定義。

### `package.json`
- **役割:** 依存関係・スクリプト。日々の実行コマンドの起点。

### `Dockerfile`／`docker-compose.yml`（プロジェクト直下）
- **役割:** 実行環境の再現。ビルド・起動コマンドやポートを定義。
- **ポイント:** node ユーザー権限、ボリューム、ポートを明示。

---

## よくある作業フロー（手に馴染ませる）

### 新機能の開始
- **新ページが要る:** `pages/` にページ作成 → 中で `features/` の部品を組む
- **既存ページからの拡張:** `features/＜機能＞` に `api/` と `hooks/` を作り、`components/` で表示

### API を呼ぶ
- `features/＜機能＞/api/` に関数を定義
- 共通設定は `services/apiClient.ts` に寄せる（ベースURL/ヘッダ/エラー処理）
- ページ側では `hooks/` を使って“どう取ってくるか”を隠蔽

### 状態の置き場所を決める
- **コンポーネントだけで完結:** `useState`（ローカル）
- **機能内で共有:** `features/＜機能＞/hooks` or 機能内の store（Zustand/Redux）
- **アプリ全体で共有:** `src/store/` にグローバル状態

### 型の置き場所
- **機能固有:** `features/＜機能＞/types.ts`
- **横断:** `src/types/`

---

## 判断基準（どこに何を置くか）

- **そのコードは他の機能で再利用できるか？**
  - はい → `src/components` / `src/hooks` / `src/utils`
  - いいえ → `src/features/＜機能名＞/...`

- **API 呼び出しは一箇所に固められているか？**
  - 各機能の `api/` に関数を置き、共通処理は `services/` へ

- **ページは“組み立てだけ”になっているか？**
  - データ取得や整形はフック・API関数へ追い出す

- **型と関数は近接しているか？**
  - 読む人が迷わないように、関連ファイルは同じ島にまとめる

---

## 小さなベストプラクティス

- **命名ルール**
  - コンポーネント: パスカルケース（`ShiftTable.tsx`）
  - 関数・フック: キャメルケース（`fetchShifts`, `useShifts`）
  - ファイル: 役割が一目で分かる名前に（`getHello.ts`, `useShifts.ts`）

- **エラーとローディング**
  - フックで `isLoading` / `error` を返して、コンポーネントで分岐表示

- **import の整理**
  - パスエイリアス（`@`）を使い、相対パスのはしごを避ける

- **環境変数**
  - `VITE_` プレフィックス必須（Viteの仕様）。`.env.example` を常に更新。

- **分割の合図**
  - 1ファイルが 150〜200行を超え出したら、関心ごとで分割する
